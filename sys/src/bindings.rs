/* automatically generated by rust-bindgen 0.59.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 32;
pub const __WORDSIZE32_SIZE_ULONG: u32 = 0;
pub const __WORDSIZE32_PTRDIFF_LONG: u32 = 0;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 32;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 0;
pub const __STATFS_MATCHES_STATFS64: u32 = 0;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const include_p256_verify: u32 = 1;
pub const include_p256_sign: u32 = 1;
pub const include_p256_keygen: u32 = 1;
pub const include_p256_ecdh: u32 = 1;
pub const include_p256_raw_scalarmult_generic: u32 = 1;
pub const include_p256_raw_scalarmult_base: u32 = 1;
pub const include_p256_to_octet_string_uncompressed: u32 = 1;
pub const include_p256_to_octet_string_compressed: u32 = 1;
pub const include_p256_to_octet_string_hybrid: u32 = 1;
pub const include_p256_decompress_point: u32 = 1;
pub const include_p256_decode_point: u32 = 1;
pub const has_fpu: u32 = 1;
pub const has_d_cache: u32 = 0;
pub const use_fast_p256_basemult: u32 = 1;
pub const use_mul_for_sqr: u32 = 0;
pub type __u_char = cty::c_uchar;
pub type __u_short = cty::c_ushort;
pub type __u_int = cty::c_uint;
pub type __u_long = cty::c_ulong;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_longlong;
pub type __uint64_t = cty::c_ulonglong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = cty::c_longlong;
pub type __u_quad_t = cty::c_ulonglong;
pub type __intmax_t = cty::c_longlong;
pub type __uintmax_t = cty::c_ulonglong;
pub type __dev_t = __uint64_t;
pub type __uid_t = cty::c_uint;
pub type __gid_t = cty::c_uint;
pub type __ino_t = cty::c_ulong;
pub type __ino64_t = __uint64_t;
pub type __mode_t = cty::c_uint;
pub type __nlink_t = cty::c_uint;
pub type __off_t = cty::c_long;
pub type __off64_t = __int64_t;
pub type __pid_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [cty::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = cty::c_long;
pub type __rlim_t = cty::c_ulong;
pub type __rlim64_t = __uint64_t;
pub type __id_t = cty::c_uint;
pub type __time_t = cty::c_long;
pub type __useconds_t = cty::c_uint;
pub type __suseconds_t = cty::c_long;
pub type __daddr_t = cty::c_int;
pub type __key_t = cty::c_int;
pub type __clockid_t = cty::c_int;
pub type __timer_t = *mut cty::c_void;
pub type __blksize_t = cty::c_long;
pub type __blkcnt_t = cty::c_long;
pub type __blkcnt64_t = __int64_t;
pub type __fsblkcnt_t = cty::c_ulong;
pub type __fsblkcnt64_t = __uint64_t;
pub type __fsfilcnt_t = cty::c_ulong;
pub type __fsfilcnt64_t = __uint64_t;
pub type __fsword_t = cty::c_int;
pub type __ssize_t = cty::c_int;
pub type __syscall_slong_t = cty::c_long;
pub type __syscall_ulong_t = cty::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut cty::c_char;
pub type __intptr_t = cty::c_int;
pub type __socklen_t = cty::c_uint;
pub type __sig_atomic_t = cty::c_int;
pub type __time64_t = __int64_t;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_int;
pub type int_fast32_t = cty::c_int;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_uint;
pub type uint_fast32_t = cty::c_uint;
pub type uint_fast64_t = cty::c_ulonglong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = cty::c_uint;
pub type wchar_t = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    #[doc = " Converts endianness by reversing the input value."]
    #[doc = ""]
    #[doc = " The output and input pointers may refer to the same location and have no alignment requirements."]
    pub fn p256_convert_endianness(
        output: *mut cty::c_void,
        input: *const cty::c_void,
        byte_len: size_t,
    );
}
extern "C" {
    #[doc = " Verifies an ECDSA signature."]
    #[doc = ""]
    #[doc = " Returns true if the signature is valid for the given input, otherwise false."]
    pub fn p256_verify(
        public_key_x: *const u32,
        public_key_y: *const u32,
        hash: *const u8,
        hashlen_in_bytes: u32,
        r: *const u32,
        s: *const u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates an ECDSA signature."]
    #[doc = ""]
    #[doc = " The parameter \"k\" shall consist of a 256-bit random integer value. This random value MUST be generated from"]
    #[doc = " a cryptographically secure random number generator, and MUST be unique for every pair of message hash and"]
    #[doc = " private key."]
    #[doc = ""]
    #[doc = " With a small probability (~ 2^-32), this function will fail and return false for the given \"k\" and this"]
    #[doc = " function MUST in that case be called again with a new random \"k\", until true is returned. This is in line"]
    #[doc = " with the ECDSA standard."]
    #[doc = ""]
    #[doc = " As an alternative to using a random \"k\", \"k\" might be derived deterministically from the input, using a"]
    #[doc = " sophisticated hash construction such as RFC 6979, or e.g. by hashing the private key, message hash and a"]
    #[doc = " retry counter, using a secure hash function such as SHA-256."]
    pub fn p256_sign(
        r: *mut u32,
        s: *mut u32,
        hash: *const u8,
        hashlen_in_bytes: u32,
        private_key: *const u32,
        k: *const u32,
    ) -> bool;
}
#[doc = " Sign precomputation state."]
#[doc = ""]
#[doc = " The content shall be treated as opaque to the API user and shall not be inspected or modified."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignPrecomp {
    pub r: [u32; 8usize],
    pub k_inv: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_SignPrecomp() {
    assert_eq!(
        ::core::mem::size_of::<SignPrecomp>(),
        64usize,
        concat!("Size of: ", stringify!(SignPrecomp))
    );
    assert_eq!(
        ::core::mem::align_of::<SignPrecomp>(),
        4usize,
        concat!("Alignment of ", stringify!(SignPrecomp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SignPrecomp>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SignPrecomp),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SignPrecomp>())).k_inv as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SignPrecomp),
            "::",
            stringify!(k_inv)
        )
    );
}
extern "C" {
    #[doc = " Creates an ECDSA signature, using a two-step procedure."]
    #[doc = ""]
    #[doc = " This function performs the first of two steps, and accounts for 99% of the time spent for generating an"]
    #[doc = " ECDSA signature."]
    #[doc = ""]
    #[doc = " By splitting up into two steps, most of the work could be spent before deciding what message to sign, or"]
    #[doc = " which private key to use."]
    #[doc = ""]
    #[doc = " The parameter \"k\" shall consist of a 256-bit random integer value. This random value MUST be generated from"]
    #[doc = " a cryptographically secure random number generator, and MUST be unique for every pair of message hash and"]
    #[doc = " private key."]
    #[doc = ""]
    #[doc = " With a small probability (~ 2^-32), this function will fail and return false for the given \"k\" and this"]
    #[doc = " function MUST in that case be called again with a new random \"k\", until true is returned. This is in line"]
    #[doc = " with the ECDSA standard."]
    #[doc = ""]
    #[doc = " As an alternative to using a random \"k\", \"k\" might be derived deterministically from the input, using a"]
    #[doc = " sophisticated hash construction such as RFC 6979, or e.g. by hashing the private key, message hash and a"]
    #[doc = " retry counter, using a secure hash function such as SHA-256."]
    #[doc = ""]
    #[doc = " The \"result\" parameter will contain the computed state, that is later to be passed to p256_sign_step2."]
    #[doc = " A result state MUST NOT be reused for generating multiple signatures."]
    pub fn p256_sign_step1(result: *mut SignPrecomp, k: *const u32) -> bool;
}
extern "C" {
    #[doc = " Second step of creating an ECDSA signature, using a two-step procedure."]
    #[doc = ""]
    #[doc = " This function performs the second of two steps, and accounts for the last 1% of the time spent for generating"]
    #[doc = " an ECDSA signature."]
    #[doc = ""]
    #[doc = " The \"sign_precomp\" parameter shall contain a pointer to a state generated by p256_sign_step1."]
    #[doc = ""]
    #[doc = " With a small probability (~ 2^-256), this function will fail, due to the given \"k\" from the first step is"]
    #[doc = " not compatible with the rest of the input, and return false. In this case, the procedure MUST be started"]
    #[doc = " over from step 1 with a new random \"k\".  This is in line with the ECDSA standard. Otherwise true is returned"]
    #[doc = " and the signature is placed in \"r\" and \"s\"."]
    #[doc = ""]
    #[doc = " When this function returns, \"sign_precomp\" is also zeroed out and may hence not be reused."]
    pub fn p256_sign_step2(
        r: *mut u32,
        s: *mut u32,
        hash: *const u8,
        hashlen_in_bytes: u32,
        private_key: *const u32,
        sign_precomp: *mut SignPrecomp,
    ) -> bool;
}
extern "C" {
    #[doc = " Calculates the public key from a given private key for use by either ECDSA or ECDH."]
    #[doc = ""]
    #[doc = " The private key shall be taken from a random value that MUST have been generated by a cryptographically"]
    #[doc = " secure random number generator that generates 256 random bits. This function validates that the private key"]
    #[doc = " lies in the accepted range 1 to n-1, where n is the order of the elliptic curve, and returns true only if"]
    #[doc = " this validation succeeds. If random value is out of that range, false is returned and in this case a new"]
    #[doc = " random value needs to be generated and this function MUST be called again until true is returned."]
    #[doc = ""]
    #[doc = " The public key is created by performing a scalar multiplication of the private key and the base point of"]
    #[doc = " the curve."]
    #[doc = ""]
    #[doc = " Only use a keypair for either ECDSA or ECDH, not both, and don't use the private key for any other purposes."]
    pub fn p256_keygen(
        public_key_x: *mut u32,
        public_key_y: *mut u32,
        private_key: *const u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Generates the shared secret according to the ECDH standard."]
    #[doc = ""]
    #[doc = " The shared secret parameter will contain the big endian encoding for the x coordinate of the scalar"]
    #[doc = " multiplication of the private key and the input point (other's public key), if the function succeeds."]
    #[doc = ""]
    #[doc = " If the other's public key point does not lie on the curve, this function fails and false is returned."]
    #[doc = " Otherwise, shared secret is calculated and true is returned."]
    #[doc = ""]
    #[doc = " NOTE: The return value MUST be checked since the other's public key point cannot generally be trusted."]
    pub fn p256_ecdh_calc_shared_secret(
        shared_secret: *mut u8,
        private_key: *const u32,
        others_public_key_x: *const u32,
        others_public_key_y: *const u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Raw scalar multiplication by the base point of the elliptic curve."]
    #[doc = ""]
    #[doc = " This function can be used to implement custom algorithms using the P-256 curve."]
    #[doc = ""]
    #[doc = " This function validates that the scalar lies in the accepted range 1 to n-1, where n is the order of the"]
    #[doc = " elliptic curve, and returns true only if this validation succeeds. Otherwise false is returned."]
    pub fn p256_scalarmult_base(result_x: *mut u32, result_y: *mut u32, scalar: *const u32)
        -> bool;
}
extern "C" {
    #[doc = " Raw scalar multiplication by any point on the elliptic curve."]
    #[doc = ""]
    #[doc = " This function can be used to implement custom algorithms using the P-256 curve."]
    #[doc = ""]
    #[doc = " This function validates all inputs and proceeds only if the scalar is within the range 1 to n-1, where n"]
    #[doc = " is the order of the elliptic curve, and the input point's coordinates are each less than the order of"]
    #[doc = " the prime field. If validation succeeds, true is returned. Otherwise false is returned."]
    pub fn p256_scalarmult_generic(
        result_x: *mut u32,
        result_y: *mut u32,
        scalar: *const u32,
        in_x: *const u32,
        in_y: *const u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Uncompressed encoding: \"04 || Px || Py\"."]
    pub fn p256_point_to_octet_string_uncompressed(out: *mut u8, x: *const u32, y: *const u32);
}
extern "C" {
    #[doc = " Compressed encoding: \"02 || Px\" if Py is even and \"03 || Px\" if Py is odd."]
    pub fn p256_point_to_octet_string_compressed(out: *mut u8, x: *const u32, y: *const u32);
}
extern "C" {
    #[doc = " Hybrid encoding: \"06 || Px || Py\" if Py is even and \"07 || Px || Py\" if Py is odd (a pretty useless encoding)."]
    pub fn p256_point_to_octet_string_hybrid(out: *mut u8, x: *const u32, y: *const u32);
}
extern "C" {
    #[doc = " Decodes a point according to the three encodings above."]
    #[doc = ""]
    #[doc = " include_p256_decode_point: first byte is \"04\", \"06\" or \"07\" and input length is 65 bytes"]
    #[doc = " include_p256_decompress_point: first byte is \"02\" or \"03\" and input length is 33 bytes"]
    #[doc = ""]
    #[doc = " Returns true if the input string confirms to a valid encoding and the point lies on the curve,"]
    #[doc = " otherwise false."]
    #[doc = ""]
    #[doc = " NOTE: The return value MUST be checked in case the point is not guaranteed to lie on the curve (e.g. if it"]
    #[doc = " is received from an untrusted party)."]
    pub fn p256_octet_string_to_point(
        x: *mut u32,
        y: *mut u32,
        input: *const u8,
        input_len_in_bytes: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Checks that the argument, as little-endian integer, is a reduced non-zero element of the scalar field."]
    #[doc = ""]
    #[doc = " In other words, that it is in the range `1..=n-1`, where `n = 2^256 - 2^224 + 2^192 - 0x4319055258e8617b0c46353d039cdaaf`."]
    #[doc = ""]
    pub fn P256_check_range_n(a: *const u32) -> bool;
}
extern "C" {
    #[doc = " Checks that the argument, as little-endian integer, is a reduced element of the base field."]
    #[doc = ""]
    #[doc = " In other words, that it is in the range `0..=p-1`, where `p = 2^256 - 2^224 + 2^192 + 2^96 - 1`."]
    pub fn P256_check_range_p(a: *const u32) -> bool;
}
